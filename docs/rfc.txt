Updated by:                                                  Meddi GUERAN
Roster LOL                                                  Jérémy BISSON
Request for Comments: 4242                                   Jérémy DELFINO
                                                             Luca GIGLIO
                                                             Alexandre VITTENET
                                                             Epitech Marseille
                                                            January 2025
Category: Standards Track
                            R-TYPE Protocol

Status of this Memo

This memo is the official specification of the R-TYPE protocol. Distribution
of this memo is unlimited.

Table of contents

    1. Introduction....................................................1
    2. R-TYPE Network Model.............................................2
    3. R-TYPE Protocol Commands........................................3
    4. R-TYPE Protocol Implementation..................................4
    5. Security and Performance Considerations.........................5
    6. Advanced Features..............................................6

1. Introduction

    The R-TYPE is an online multiplayer game that requires real-time communication
    between clients and server. The protocol is built around binary-encoded
    actions using a 5-bit system, allowing for efficient packet transmission
    while maintaining readability through debug color coding.

    The protocol defines a set of specific actions that cover all game events
    from movement to power-up spawning. Each action can carry additional
    parameters as needed.

2. R-Type Network Model

    The server manages client connections through UDP endpoints, with each client
    being tracked in a ClientInfo structure containing:
        - Name (string)
        - Connection status (bool)
        - Endpoint information (IP:Port)

    Messages are encoded using a 5-bit binary system where each action is
    represented by a unique binary code. The message structure is:
        BINARY_CODE [ARGUMENT1] [ARGUMENT2] ...

    Example:
        "00001 playerID position" represents a SHOOT action

3. R-TYPE Protocol Commands

    The protocol defines the following actions:
    +---------------+------------+--------------------+
    | Action        | Binary     | Description       |
    +---------------+------------+--------------------+
    | NONE          | 0b0000     | No action         |
    | SHOOT         | 0b0001     | Player shoots     |
    | MOVE          | 0b0010     | Generic movement  |
    | DOWN          | 0b0011     | Move downward     |
    | LEFT          | 0b0100     | Move left         |
    | RIGHT         | 0b0101     | Move right        |
    | UP            | 0b0110     | Move upward       |
    | STOP          | 0b0111     | Stop movement     |
    | POWER_UP      | 0b1000     | Use power-up      |
    | POWER_UP_SPAWN| 0b1001     | Spawn power-up    |
    | RESPAWN       | 0b1010     | Player respawn    |
    | MOB_SPAWN     | 0b1011     | Spawn enemy       |
    | MOB_SHOOT     | 0b1100     | Enemy shoots      |
    | QUIT          | 0b1111     | Exit game         |
    | STOP_Y        | 0b10000    | Stop vertical     |
    | STOP_X        | 0b10001    | Stop horizontal   |
    | DEATH         | 0b10010    | Player death      |
    | COLLISION     | 0b10100    | Object collision  |
    | WIN           | 0b10101    | Game won          |
    | LOOSE         | 0b10110    | Game lost         |
    | START         | 0b10111    | Game start        |
    | SCORE_UPDATE  | 0b11001    | Update score      |
    | SAVE_REPLAY   | 0b11010    | Save game replay  |
    | DISCONNECT    | 0b11011    | Client disconnect |
    | PLAY_REPLAY   | 0b11100    | Play saved replay |
    | CONNECT       | 0b11111    | Client connect    |
    +---------------+------------+--------------------+

4. R-TYPE Protocol Implementation

    The server implementation uses boost::asio for network operations and
    runs on multiple threads:
    - Main thread for server management
    - Receive thread for handling incoming messages
    - Game logic thread for state updates

    Message handling follows this flow:
    1. Receive raw message from client
    2. Decode binary action code
    3. Parse additional arguments
    4. Process game action
    5. Broadcast updates to other clients

    Debug messages use color coding for better visibility:
    - GREEN: Server status messages
    - RED: Disconnection events
    - YELLOW: Connection events
    - BLUE: Action logging

5. Security and Performance Considerations

    The system implements several important features for game stability:
    - Thread-safe message handling
    - Asynchronous network operations
    - Binary encoding for reduced bandwidth
    - Broadcast optimization (sender excluded from broadcasts)
    - Comprehensive error handling
    - Debug logging system

    The UDP protocol was chosen for its low latency characteristics,
    essential for real-time gameplay. While it doesn't guarantee delivery,
    the game design accounts for potential packet loss through regular
    state updates and client-side prediction.

6. Advanced Features

    6.1 Replay System
    The protocol includes support for game replay functionality:
    - SAVE_REPLAY: Store game actions for later playback
    - PLAY_REPLAY: Replay stored game sessions
    
    Replay data format:
    - Timestamped sequence of game actions
    - Player positions and states
    - Game events and outcomes

    6.2 Game State Management
    Enhanced state control commands:
    - START: Initialize new game session
    - WIN/LOOSE: Game outcome signals
    - SCORE_UPDATE: Real-time scoring updates

    6.3 Extended Enemy Behavior
    Additional enemy-related actions:
    - MOB_SHOOT: Separate action for enemy projectiles
    - MOB_SPAWN: Controlled enemy spawning

    6.4 Movement Precision
    Granular movement control:
    - STOP_X/STOP_Y: Axis-specific movement stops
    - Separate vertical and horizontal controls

Implementation Recommendations:
    1. Use thread-safe queues for message processing
    2. Implement retry mechanism for critical actions
    3. Include client-side prediction
    4. Maintain action history for replay support
    5. Monitor network performance metrics